<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Truncate</title>
    <style>
        :root {
            --water: #50a7e8;
        }

        @font-face {
            font-family: Truncate;
            src: url({{assets.font}});
        }

        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: sans-serif;
        }

        #splash {
            position: absolute;
            top: 0;
            left: 0;
            transform: scale(0.5);
            transform-origin: top left;
            background-color: var(--water);
        }
    </style>
</head>

<body>
    <canvas id="splash"></canvas>

    <script>
        (function () {
            const canvas = document.getElementById("splash");
            let output_size, midpoint;

            const refit = () => {
                canvas.width = document.body.clientWidth * 2;
                canvas.height = document.body.clientHeight * 2;

                const calc_output = () => {
                    let size = canvas.width / 20;
                    size = Math.min(size, 64);
                    return size - (size % 2);
                }
                const calc_midpoint = () => {
                    let x = Math.round(canvas.width / 2);
                    let y = Math.round(canvas.height / 2);
                    return [x - (x % 2), y - (y % 2)];
                }

                output_size = calc_output();
                midpoint = calc_midpoint();
            }
            refit();

            const image = new Image();
            image.src = "{{assets.tiles}}";

            const paint = {
                tile_size: 16,
                tile: (index, x, y) => {
                    let tile_pos = index * (paint.tile_size + 2);
                    ctx.drawImage(
                        image,
                        tile_pos + 1, 1, paint.tile_size, paint.tile_size,
                        x, y, output_size, output_size
                    );
                },
                tiles: (indexes, x, y) => {
                    for (let row_i = 0; row_i < indexes.length; row_i += 1) {
                        const row = indexes[row_i];
                        for (let column_i = 0; column_i < row.length; column_i += 1) {
                            const tile = parseInt(row[column_i]);
                            paint.tile(tile, x + column_i * output_size, y + row_i * output_size);
                        }
                    }
                }
            };

            const pick = {
                grass: () => 20 + Math.ceil(Math.random() * 4)
            }

            const render = {
                name: (name) => {
                    name = name.toUpperCase();
                    const name_width = name.length * (output_size * 2) + (output_size * 2);
                    const x = midpoint[0] - name_width / 2, y = midpoint[1] - output_size * 2;

                    // Land
                    paint.tiles([[4], [10], [10], [15]], x, y);
                    for (let c = 1; c <= name.length * 2; c += 1) {
                        paint.tiles([[5], [pick.grass()], [pick.grass()], [16]], x + c * output_size, y);
                    }
                    paint.tiles([[6], [11], [11], [17]], x + ((name.length * 2) + 1) * output_size, y);

                    ctx.font = `${output_size * 0.9}px Truncate`;
                    ctx.textAlign = `center`;
                    ctx.textBaseline = `middle`;

                    // Tiles
                    const tiles = name.split('');
                    for (let c = 1; c <= name.length * 2; c += 2) {
                        paint.tiles([[53, 54], [56, 55]], x + c * output_size, y + output_size);

                        const tile = tiles.shift();
                        const metric = ctx.measureText(tile);
                        const shift = (metric.actualBoundingBoxLeft - metric.actualBoundingBoxRight) / 2;
                        ctx.fillText(tile, x + c * output_size + output_size + shift, y + output_size * 2 - output_size * 0.03, output_size * 2);
                    }
                }
            };

            const ctx = canvas.getContext("2d");
            const the_guts = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.imageSmoothingEnabled = false;

                render.name("TRUNCATE");
            }

            image.onload = function () {
                the_guts();
                window.addEventListener("resize", () => {
                    refit();
                    the_guts();
                })
            };
        })();
    </script>
</body>

</html>